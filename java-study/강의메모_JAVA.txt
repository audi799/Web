## 공통 ##
[ 서론 ]
- 자바(Java) 언어는 컴파일 시 바이트 코드가 되는 언어로, 개발자가 작성한 코드가 바이트 코드로 컴파일 되어 운영체제 커널(Kernel)이 이를 직접 읽어들이지 않고, JRE(Java Runtime Environment)가 해당 바이트 코드를 읽어 들여 그 결과인 바이너리 코드를 운영체제 커널이 이해할 수 있는 형태로 전달하는 방식을 채택하고 있다.
- 이러한 방식 때문에, 각 운영체제에 맞는 JRE 가 적절하게 구축되어 있다면 하나의 코드로 운영체제와 무관하게 개발 및 실행할 수 있다는 장점이 있지만, 컴파일 결과가 즉시 바이너리 코드로 변환되는 언어에 비해 속도가 느리다는 단점이 있다.

[ JRE ]
- JRE(Java Runtime Environment)는 자바로 작성된 프로그램을 실행하기 위해 필요한 구성요소의 집합인 소프트웨어이다.

[ JDK ]
- JDK(Java Development Kit)는 자바로 프로그램을 개발하고 실행하기 위한 구성요소의 집합인 소프트웨어이다. 이는 JRE 를 포함하고 있다.

[ JVM ]
- JVM(Java Virtual machine)은 자바로 개발된 프로그램을 실행하기 위해 구축된 가상의 환경을 의미한다.
- JRE 설치 후 실제로 자바로 작성된 프로그램을 구동하여 바이너리 코드로 변환하는 실행 환경이다.

* 자바 프로젝트 생성 시,
groupId: 도메인의 역순 ex) com.naver
artifactId: 프로젝트 이름 ex) cafe
베이스 패키지: groupId + artifactId
-> com.naver.cafe

## 타입 ##
- 타입(Type)은 어떠한 값을 담을 수 있는 형태(종류)이다. 크게 기초 타입과 참조 타입으로 나누어져있다.

[ 기초 타입 ]
- 기초 타입(기본 타입, 원시 타입, Primitive Type)은 해당 타입의 변수 값이 리터럴(Literal)이고 메모리의 스택(Stack)영억에 값이 직접 할당되는 타입니다.
- 정수형
  + byte: (1 Byte) -128 이상 127 이하의 정수
  + short: (2 Bytes) -32,768 이상 32,767 이하의 정수
  + int: (4 Bytes) -2.147,483,648 이상 2,147,483,647 이하의 정수
  + long: (8 Bytes) -9,223,372,036,854,775,888 이상 9,223,372,036,854,775,887 이하의 정수.
    리터럴 숫자 끝에 L 을 붙임으로써 long 타입의 숫자임을 명시적으로 표현할 수 있다. 가령 314L 은 long 타입인 314이다.
  + 보다 작은 타입의 값을 보다 큰 타입에 할당하는 것은 가능하지만, 보다 큰 타입의 값을 보다 작은 타입에 할당하는 것은 (강제 형변환을 통하지 않으면) 허용되지 않는다.
  + 별도의 명시가 없는 정수 표기는 모두 int 타입으로 간주한다. 단, 아래의 경우는 예외로 한다.
    # -128 이상 127 이하 정수 리터럴을 byte 타입의 변수에 할당하는 경우
    # -32,768 이상 32,767 이하의 정수 리터럴을 short 타입의 변수에 할당하는 경우
- 실수형
  + float: (4 Bytes) 1.4E-45 이상 3.4E+30 이하의 실수. 리터럴인 숫자 끝에 F를 붙임으로써 float 타입의 숫자임을 명시적으로 표시할 수 있다. 314f는 float 타입의 314 이다.
  + double: (8 Bytes) 4.9E-324 이상 1.79E+388 이하의 실수. 리터럴인 숫자 끝에 D를 붙임으로써 double 타입의 숫자임을 명시적으로 표시할 수 있다. 314D는 double 타입인 314 이다.
- 문자형
  + char: (2 Bytes) 문자 하나를 담기 위해 사용하는 타입이다. 특수 문자 홑따옴표(')를 사용한다. 역슬래쉬(\)를 활용하여 특수한 문자를 할당할 수 있다.
          가령, 개행자는 \n이고, 공란은 \a와 같다. 문자형  타입의 값은 비어있을 수 없음에 유의한다.
- 논리형
  + boolean: (1 Byte) 참(true) 과 거짓(false)을 가진다.

[ 참조 타입 ]
- 참조 타입(레퍼런스 타입, Reference Type)은 해당 타입의 변수 값이 리터럴이지 않고(문자열 string 예외), 메모리의 스택(Stack)영억에서는 힙(Heap)의 주소가, 힙 영역에서는 실질적인 값(혹은 딕셔너리)이 저장된다.
- 기초 타입을 제외한 나머지 모든 타입은 참조 타입이다.
- 참조 타입은 new 키워드를 통해 객체화(Instantiation)하여 구현하고, 이 값을 객체라고 한다. 이 객체의 메모리 크기는 가변적이다.
- 대표적인 참조 타입으로 문자열(String)이 있다. 문자열은 객체화 과정(new)을 생략하고 쌍따옴표(") 특수기호를 통해 리터럴처럼 사용할 수 있다.

[ 형변환 ]

## 변수 ##
- 변수(Variable)는 타입과 이름을 가지고 타입에 부합하는 값을 할당하여 활용하기 위해 사용한다. 종류는 지역 변수와 멤버 변수, 매개 변수 등으로 나눌 수 있다.

[ 지역 변수 ]
- 명명법: 카멜케이스
- 지역 변수(Local Variable)는 메서드(Method)안에 존재하는 변수이다.
- 지역 변수에 값이 할당된 적이 없다면, 값 할당을 제외한 접근이 제한된다.
- 선언 방식은 아래와 같다.
  [타입] [이름];
  # 혹은 선언과 동시에 값을 초기화하기 위해 아래와 같이 작성할 수 있다.
  [타입] [이름] = [값];
  # 가령, 타입이 정수형(int)이고, 이름이 age 이며, 초기값이 25인 변수의 선언은 아래와 같이 할 수 있다.
  int age = 25;

[ 멤버 변수 ]
- 멤버 변수(Member Variable)는 클래스나 인터페이스 등의 구성 요소가 직접 가지는 변수이다.
- 상수가 아닌 멤버 변수에 값을 할당한적이 없다면, 자동으로 기본 값이 할당된다.
  + 정수 및 실수 등 숫자 기초타입: 0
  + 문자 기초 타입: \0
  + 논리 기초 타입: false
  + 모든 참조 타입: null
- 상수인 멤버 변수의 값은 반드시 직접 할당하거나, 생성자를 통해 초기화하여야 한다. 단, 하나의 멤버 변수에 대해 두 방식을 동시에 사용할 수는 없다.

[ 매개 변수 ]
- 매개 변수(Parameter)는 메서드 호출 시 인자(Argument)를 전달 받기 위해 사용하는 변수이다.

## 상수(읽기 전용) ##
- 명명법: 카멜케이스
- 읽기 전용 변수는 편의상 상수라고 많이 부르며 final 키워드를 통해 변수의 (스택)값이 한번 할당된 이후로 변할 수 없음을 지정한다.
- final 키워드를 사용하였다 하더라도 참조 타입의 객체가 가지는 힙 영역의 내용에 대한 불변성(immutability)이 보장되는 것은 아님으로 엄밀히 말하면 상수(Constant)라고 말하면 안되나, 편의상 상수라고 많이 얘기한다.
- 정적이면서 읽기 전용(static final)이며 리터럴인 멤버 변수에 한해 대문자 스네이크 케이스 명명법을 사용한다.
- 선언 방식은 아래와 같다.
  final [타입] [이름] = [값];
  # 지역 변수는 읽기 전용으로 지정하여도 값 초기화를 할 필요는 없기 때문에 아래와 같이 선언할 수 있다.
  final [타입] [이름];

## 연산자 ##
[ 할당 연산자 ]
- 일반 할당(=): x = y 꼴에서 x 에 y를 할당한다.
- 더하기 복합 대입연산(+=): x += y 꼴에서 x와 y를 더한 값을 x에 재할당 한다.
- 빼기 복합 대입 연산(-=): x -= y 꼴에서 x에서 y를 뺀 값을 x에 재할당 한다.
- 곱하기 복합 대입 연산(*=): x *= y 꼴에서 x와 y를 곱한 값을 x에 재할당 한다.
- 나누기 복합 대입 연산(/=): x /= y 꼴에서 x를 y로 나눈 몫을 x 에 재할당 한다.
- 나머지 복합 대입 연산(%=): x %= y 꼴에서 x를 y로 나눈 나머지를 x에 재할당 한다.

[ 비교 연산자 ]
- 비교 연산자에 사용되는 피연산자의 타입은 같거나 묵시적 형변환이 가능한 관계여야 한다.
- 동등(==): x == y 꼴에서 x 와 y 가 가진 스택 값이 같은가의 여부이다.
- 부등(!=): x != y 꼴에서 x 와 y 가 가진 스택 값이 다른가의 여부이다.
- 초과(>): x > y 꼴에서 x 가 y 보다 큰가의 여부이다.
- 미만(<): x < y 꼴에서 x 가 y 보다 작은가의 여부이다.
- 이상(>=): x >= y 꼴에서 x 가 y 보다 크거나 같은가의 여부이다.
- 이하(<=): x <= y 꼴에서 x 가 y 보다 작거나 같은가의 여부이다.

[ 산술 연산자 ]
- 더하기(+): x + y 꼴에서 x 와 y 의 합이다.
- 빼기(-): x - y  꼴에서 x에서 y를 뺀 값이다.
- 곱하기(*): x * y 꼴에서 x 와 y 의 곱이다.
- 나누기(/): x / y 꼴에서 x 를 y 로 나눈 몫이다.
- 나머지(%): x % y 꼴에서 x 를 y 로 나눈 나머지이다.
- 단항 양수(+): +x 꼴에서 변수 x 의 부호를 강조한다.
- 단항 음수(-): -x 꼴에서 변수 x 의 부호를 반전한다.
- 증가(++)
  + 전위 증가: ++x 꼴에서 구문 실행 전 x에 1을 더한다.
  - 후위 증가: x++ 꼴에서 구문 실행 후 x에 1을 더한다.
- 감소(--)
  + 전위 감소: --x 꼴에서 구문 실행 전 x에 1을 뺀다.
  + 후위 감소: x-- 꼴에서 구문 실행 후 x에 1을 뺀다.
- 자바가 가지는 숫자 타입간의 사칙 연산 결과는 두 피연산자의 타입이 같다면 반드시 동일 타입으로, 다르다면 보다 큰 타입으로 연산된다.
- 단, 사칙연산의 두 피연산자가 int 이하의 정수 타입일 경우 그 결과는 int 이다.
  + 단, int 미만인 두 피연산자의 사칙연산 결과를 int 미만의 타입인 변수에 할당코자할 때 두 피연산자가 상수(final)이고, 그 결과가 해당 타입의 한계값의 범위내에 있다면 할당 가능하다.
  + 추가로, 복합 대입 연산자를 사용할 경우 묵시적 형변환이 발생한다.

[ 논리 연산자 ]
- 논리 AND(&&): x && y 꼴에서 x 와 y 가 모두 참(true)인가의 여부이다.
- 논리 OR(||): x || y 꼴에서 x 와 y 중 하나가 참(true)인가의 여부이다.
- 논리 NOT(!): !x 꼴에서 x 의 논리를 부정(반전)한다.

[ 삼항 연산자 ]
- 삼항 연산자(? : ): c? t : f 꼴에서 조건 c 가 참(true)이라면 t, 거짓(false)이라면 f가 된다.

[ 기타 연산자 ]
- 멤버접근(.): x.y 꼴에서 x의 멤버인 y에 접근하기 위해 사용한다.
- 배열 인자 접근([]): x[y] 꼴에서 배열인 x의 인자 중 순번이 y인 인자에 접근하기 위해 사용한다.
- 객체화(new): new T 꼴에서 타입 T를 객체화하기 위해 사용한다.
- 메서드 호출( () ): m() 꼴에서 메서드 m을 호출하기 위해 사용한다.
- 우선 연산( () ) (x) 꼴에서 연산 x를 우선하기 위해 사용한다.
- 단항 형 변환( (T) ): (T) x 꼴에서 x 의 타입을 강제로(명시적) T로 변환한다.
- 타입 비교(instanceof): x instanceof T 꼴에서 값 x가 타입 T로 형변환될 수 있는가의 여부이다.

[ 연산자의 우선순위 ]
- 연산자 사이에는 연산되는 우선순위가 있으며 아래는 숫자가 작을수록 우선순위가 높다는 의미이다. (1번이 가장 높은 우선순위)
1.우선 연산, 배열 인자 접근, 멤버 접근( (), [], .)
2.후위 증가, 후위 감소(++, --)
3.전위 증가, 전위감소, 단항 양수, 단항 음수, 논리 NOT (++, --, +, -, !)
4.객체화(new)
5.곱하기, 나누기, 나머지(*, /, %)
6.더하기, 빼기(+, -)
7.초과, 미만, 이상, 이하, 타입 비교(>, <, >=, <=, instanceof)
8.동등, 부등(==, !=)
9.논리 AND (&&)
10.논리 OR (||)
11.삼항 연산자(?:)
12.할당, 복합 대입 연산(=, +=, -=, **, /=, %=)

## 반복문 ##
[ for ]
- for 반복문은 반복의 기준이되는 변수(주로 인덱스)를 활용하여 특정 구현부를 반복 실행하고자 할때 사용한다.
  for ([변수 선언 및 초기화]; [반복 조건]; [변수 가감 및 할당]) {
    [구현부]
  }
  #1. for 반복문을 위한 변수 선언 및 초기화
  #2. 반복 조건이 참(true)인지 확인한다.
      + 반복 조건이 참(true)이라면 구현부를 1회 실행하고 #3. 으로 이동한다.
      + 반복 조건이 거짓(false)이라면 for 반복문 실행을 즉시 종료한다.
  #3. 변수 가감 및 할당을 실시하고 #2. 로 돌아간다.

[ 향상된 for(Enhanced For) ]
- 향상된 for(Enhanced For) 반복문은 반복할 수 있는 대상이 가지는 인자에 대해 반복하기 위해 사용한다.
- 인덱스가 필요 없늘 경우 인덱스 범위 오류 최소화 및 가독성 향상 등을 위하여 가능한한 향상된 for 반복문을 사용하는 것이 권장된다.
  for ([변수 선언] : [반복 대상]) {
    [구현부]
  }

[ while ]
- while 반복문은 주어진 조건이 참(true)일 때 횟수와 관계 없이 구현부를 실행하기 위해 사용한다.
  while ([조건]) {
    [구현부]
  }
  #만약 조건이 항상 참이거나, 거짓으로 변하는 경우의 수가 없다면, 혹은 break 및 return 등의 중단 키워드가 없는 경우 무한히 반복됨으로 유의해야 한다.

[ do while ]
- do ... while 반복문은 while 반복문과 유사하나 조건과 관계 없이 최초 한번은 반드시 구현부를 실행한다는 차이점이 있다.
  do {
    [구현부]
  } while ([조건]);
  #만약 조건이 항상 참이거나, 거짓으로 변하는 경우의 수가 없다면, 혹은 break 및 return 등의 중단 키워드가 없는 경우 무한히 반복됨으로 유의해야 한다.

## 조건문 ##
[ if ]
- 주어진 조건이 참일때만 구현부를 실행하기 위해 사용한다.
    if ([조건]) {
        [구현부]
    }

[ else ]
- else 문은 단독으로 사용할 수 없고, if 문과 함께 사용햐여야 한다.
- else 문은 앞서 제시된 모든 조건이 거짓일 때 최종적으로 실행할 구현부를 위해 사용한다.
- else 문은 if 문 하나에 여러개 존재할 수 없다.
- else 문은 if 문의 마지막 구문이어야 한다.
    if ([조건]) {
        [참 구현부]
    } else {
        [거짓 구현부]
    }
    #위 예시에서 조건이 참일때는 참 구현부를, 거짓일때는 거짓 구현부를 실행한다.
    #조건이 논리임으로, 참 구현부 혹은 거짓 구현부 중 하나가 반드시 실행된다는 보장이 있다.

[ else if ]
- else if 문은 단독으로 사용할 수 없고, if 문과 함께 사용하여야 한다.
- else if 문은 앞서 제시된 모든 조건이 거짓일 때 부수적인 조건을 추가하여 해당 조건이 참일 때 구현부를 실행하기 위해 사용한다.
- else if 문은 if 문 하나에 여러개 존재할 수 있다.
- else if 문의 조건이 비록 참이라 하더라도 선행하는 if 혹은 else if 의 조건이 참이라면 해당 후행하는 else if 는 실행되지 않는다. (하나의 if 문에서 실행될 수 있는 구현부는 하나 이하임으로)
    if ([선행 조건 1]) {
        [선행 조건 1 구현부]
    } else if ([선행 조건 2]) {
        [선행 조건 2 구현부]
    } else if ([선행 조건 3]) {
        [선행 조건 3 구현부]
    } else {
        [거짓 구현부]
    }
    #위 예시에서 선행 조건 1 이 참일 경우 선행 조건 1 구현부 를 실행하고나머지 else if 와 else 는 고려하지 않는다.
    #위 예시에서 선행 조건 1 이 거짓이고 선행 조건 2 가 참인 경우 선행 조건 2 구현부 를 실행하고 후행하는 else if 와 else 는 고려하지 않는다.
    #위 예시에서 선행 조건 1 및 선행 조건 2 가 거짓이고 선행 조건 1이 참인 경우 선행 조건 3 구현부 를 실행하고 후행하는 else 는 고려하지 않는다.
    #위 예시에서 선행 조건 1, 선행 조건 2, 선행 조건 3 이 모두 거짓이라면 else 를 실행한다.
    #즉, else if 의 개수 및 else 의 존재 여부와 무관하게 하나의 if 문에 존재하는 구현부는 실행되지 않거나, 단 한개만 실행 할 수 있다.

## 분기문 ##
[ switch ]
- switch 분기문은 분기 대상 변수가 가지는 값에 따라 case 를 활용하여 실행할 구문을 분리하기 위해 사용한다.
    switch ([분기 대상 변수]) {
      case [값 1]:
            [값 1 구현부]
            [break;]?
      case [값 2]:
            [값 2 구현부]
            [break;]?
      [default:]?
            [default 구현부]?
    }
    #case 에 명시하는 값은 리터럴이거나 상수(final)여야 한다.
    #case 에 명시하는 값은 사칙연산일 수 있지만 메서드 호출일 수 없다.

## 배열 ##
- 배열(Array)은 하나의 변수로 동일하거나 호환되는(묵시적 형변환이 가능한) 타입의 값을 여러개 가질 수 있도록 하기위해 사용한다.
- 배열은 비록 이가 가질 인자의 타입이 기초 타입이라 하더라도 메모리의 작동 방식은 참조 타입과 같다. 고로 null 값을 가질 수 있다.
- 변수 선언시 타입의 대괄호([])를 활용하여 해당 변수가 배열임을 나타낸다.
- 배열의 이름은 주로 복수형으로 짓거나, 접미어로 Array 를 붙여 짓는 편이다.
  T[] 이름;
  #가령, 정수(int) 배열인 nums 는 아래와 같이 만들 수 있다.
  int[] nums[];

[ 초기화 ]
- 배열의 초기화는 인자의 나열 혹은 배열의 길이 지정 중 하나여야 한다.
- 배열이 초기화 된 후에는 다시 초기화 하는 방법 외에 배열이 가질 수 있는 인자의 개수를 줄이거나 늘릴 수 없다.
- 배열이 가질 인자의 나열은 아래 방식으로 한다.
  T[] ts = new T[] {t1, t2, t3};
  #가령, 정수(int) 배열에 대해 인자 1, 2, 3 을 가지는 배열의 초기화는 아래와 같이 할 수 있다.
  int[] nums = new int[] {1, 2, 3};
  #혹은 아래와 같이 문맥상 그 타입이 명확한 경우 객체화 연산자를 생략할 수 있다.
  int[] nums = {1, 2, 3};
- 배열의 길이 지정은 아래 방식으로 한다.
  T[] ts = new T[n];
  #가령, 정수(int) 배열에 대해 길이가 3인 배열의 초기화는 아래와 같이 할 수 있다.
  int nums = new int[3];
  #길이 지정을 통해 초기화된 배열이 가지는 모든 인자는 기본 값으로 초기화되며 기본 값은 아래와 같다.
    + 정수 및 실수 등 숫자 기초타입: 0
    + 문자 기초 타입: \0
    + 논리 기초 타입: false
    + 모든 참조 타입: null
- 인자의 나열과 배열의 길이 지정을 동시에 사용하여서는 안된다.
  int[] nums = new int[3] {1, 2, 3};
  #위와 같이 배열의 길이도 지정하고(3), 인자의 나열 ({1,2,3}} 하여서는 안된다.

[ 인자 ]
- 배열은 배열이 가지는 각 인자에 대해 인덱스를 가지고 있는데, 이 인덱스는 반드시 0 부터 시작하여 1씩 증가한다.
- 배열이 가지는 인자에 순번으로 접근하기 위해서는 배열 변수에 대해 대괄호([])를 사용할 수 있다.
  int[] odds = new int[] {1, 3, 5, 7, 9};
  System.out.println(odds[1]); // 3
  System.out.println(odds[3]); // 7

- 배열이 가지고 있는 인자에 값을 재할당하고자 할때 그 순번으로 접근하여 재할당 할 수 있다.
  int[] odds = new int[] {1, 3, 5, 7, 9};
  System.out.println(odds[2]); // 5
  odds[2] = 11;
  System.out.println(odds[2]); // 11

- 배열이 가지고 있는 인자의 개수를 가지고 있는 속성은 length 이다.
  int[] odds = new int[] {1, 3, 5, 7, 9};
  System.out.println(odds.length); // 5
  #모든 인자를 가지는 모든 배열의 length 속성 값에서 1을 뺀 값은 항상 마지막 인자의 순번이다.
  #배열이 가지고 있는 인자의 인덱스의 범위를 벗어난 인자에 접근할 경우 ArrayIndexOutOfBoundsException 예외(Exception)가 발생함으로 유의한다.

- 배열의 메모리 생태는 참조 타입과 같음으로 배열이 가지는 인자의 동등 여부를 비교할때에는 배열간에 동등부 비교를 하지 않도록 한다.
  int[] nums1 = new int[] {1, 2, 3};
  int[] nums2 = new int[] {1, 2, 3};
  System.out.println(nums1 == nums2); // false
  #대신, 두 배열의 길이가 같고 두 배열이 가지는 인자들이 서로 equals 메서드의 대해 true 를 반환하는가의 여부를 반환하는 메서드 Arrays의 equals 를 활용하도록 한다.
  int[] nums1 = new int[] {1, 2, 3};
  int[] nums2 = new int[] {1, 2, 3};
  System.out.println(Arrays.equals(num1, num2));

## 메서드 ##
- 메서드(메소드,Method) 는 클래스 혹은 인터페이스 등의 구성요소가 가지는 멤버(Member)중 하나이며 호출(Call, Invoke) 가능한 동작 단위인 대상이다.
- 메서드 작성시, 메서드의 이름에 따라 최소한의 역할만 하도록 로직을 작성하는 것이 중요하다.
- 명명법: 카멜케이스(V, V+O, be+Adj)
- 메서드의 구조는 아래와 같다.
  [접근 제한자] [abstract|final|static]? [반환 타입|void] [메서드 이름] ([매개변수, ...]?) {
    [구현부]
  }
  #abstract: 해당 메서드가 추상 메서드임을 의미한다.
   + 추상 메서드의 접근 제한자는 private 일 수 없다.
   + 추상 메서드는 정적 (static)일 수 없다.
   + 추상 메서드는 구현부를 가지지 않아야 한다.
   + 추후 해당 메서드를 멤버로 가지는 클래스를 상속 받거나 인터페이스를 구현하는 대상으로 하여금 해당 메서드의 구현부를 직접 구현하도록 한다.
  #final: 해당 메서드가 최종적임을 의미한다.
   + 최종적인 메서드는 재정의(Override)할 수 없다.
   + 최종적인 메서드는 추상적(abstract)일 수 없다.
   + 해당 메서드의 구현부는 절대적이고 앞으로 변하여서는 안 되는 로직을 가지는 경우 최종적으로 만든다.
  #static: 해당 메서드가 정적임을 의미한다. 정적인 메서드는 주로 유틸리티성을 가지며, 객체가 아닌 타입의 이름으로 접근할 수 있다.
   + 정적인 메서드는 추상적(abstract)일 수 없다.
   + 정적인 메서드는 재정의 대상이 아님으로 최종적(final)일 필요가 없다.
   + 정적인 메서드는 이를 가지고 잇는 타입이 객체화 되지 않아도 프로그램이 실행될 때 그 존재가 메모리에 등록된다.
  #void: 해당 메서드의 반환 값이 없음을 의미한다. 호출 결과로 어떠한 값도 반환(return)할 수 없다. (단, 메서드 종료를 위한 단순 return 은 사용 가능)
   + 반환 타입이 있는 경우 명시적으로 예외를 던지는(throw 하는) 경우를 제외하고 모든 경우의 수에서 값을 반환(return)하여야 한다. (일부 무한 루프 등 제외)

[ 매개 변수 ]
- 매개 변수(Parameter)는 메서드가 요구하는 변수 구성이다.
- 해당 메서드를 호출할 때 요구되는 매개변수에 대해 전달하는 값을 전달 인자(Argument)라고 한다.
- 명명법: 카멜케이스
- 매개 변수의 구조는 아래와 같고 쉼표(,)로 구분하여 여러개 작성할 수 있다.
  [final]? [타입] [이름]

[ 가변 인자 ]
- 가변 인자(Variable Argument)는 실질적으로 배열이지만 호출자로 하여금 단순히 쉼표(,)로 구분하여 전달 인자를 쉽게 전달할 수 있게하기 위해 사용한다.
  [final]? [타입]... [이름]
  # 위와 같이 타입 뒤에 ... 를 붙여 이가 가변인자임을 설정한다.
- 단, 매개 변수 구조상 가변 인자는 반드시 마지막에 위치하여야 한다,. (일반 매개 변수와 구분할 수 없으므로)
  public static int sum(int first, int ... nums) {
    ...
  }
  # 위 구조는 가변 인자 nums 가 마지막 매개 변수임으로 문제가 없다.

  public static int sum(int first, int ... nums, boolean unsafe) {
    ...
  }
  # 위 구조는 가변 인자 nums 가 마지막 매개 변수가 아님으로 올바르지 않은 구조이다.

## 클래스 ##
- 클래스(Class)는 서로 관련 있는 멤버(멤버변수 및 메서드 등)의 집합이다.
- 명명법: 파스칼 케이스
- 클래스의 구조는 아래와 같다.
  [접근 제한자] [abstract|final]? class [클래스 이름] [extends 부모 클래스]? [implements 인터페이스, ...]? {
    [멤버...]
  }
  #abstract: 해당 클래스를 추상 클래스로 지정한다. 해당 클래스가 추상 메서드를 한 개 이상 가지려면 반드시 추상 클래스로 지정되어야 한다.
  #final: 해당 클래스를 최종 클래스로 지정한다. 최종 클래스는 상속 대상이 될 수 없다.
  #extends: 상속 받을 클래스를 지정한다.
  #implements: 구현할 인터페이스(들)를 지정한다.

[ 객체 ]
- 객체(Instance)는 객체화 연산(new)을 통해 참조 타입이 객체화된 대상을 의미한다.

[ 생성자 ]
- 생성자(Constructor)는 어떠한 타입이 객체화될 때 반드시 실행되는 일종의 특수한 메서드이다.
- 객체화 연산(new)시 타입 뒤에 적는 괄호(()) 는 생성자 호출이다.
  String str = new String("Hi");
                         ↑ 생성자 호출
- 생성자의 구조는 아래와 같다.
  [접근 제한자] [클래스 이름] ([매개변수, ...]) {
    [구현부]
  }
  #생성자의 이름은 반드시 클래스의 이름과 일치해야 한다.
  #생성자는 반환 타입을 가지지 않는다. (void 를 명시하지도 않는다.)
  #생성자는 추상적(abstract)이거나 최종적(final), 정적(static)일 수 없다.
  #객체화 연산 외에는 임의로 호출할 수 없다.
  #생성자 구현부의 첫 구문은 반드시 부모 클래스의 생성자 호출(super(...))이거나 자신 클래스의 생성자 호출(this(...))이어야 한다.

[ 기본 생성자 ]
- 모든 클래스는 생성자로 반드시 가지며 별도의 생성자를 명시하지 않을 경우 기본 생성자가 생략된 상태로 존재한다.
- 기본 생성자의 구조는 아래와 같다.
  public [클래스 이름]() {
    super();
  }

## 상속 ##
- 상속(Inheritance)은 어떠한 클래스가 다른 클래스로 하여금 다른 클래스의 기능을 그대로 물려받아 새로운 기능을 확장시키기 위해 사용한다.
- 어떠한 클래스에게 상속 받을 클래스를 명시하지 않을 경우 모든 클래스는 자동으로 Object(java.lang.Object) 클래스를 상속 받는다.
- 상속 받은 클래스를 명시하는 것이 보다 상위 계층의 상속 클래스에 대한 기능 확장을 상실하는 것을 의미하지 않는다.
- 다중 상속 관계는 허용되지 않으며 반드시 한 개의 클래스를 상속 받아야한다.
- 순환 상속 구조를 가질 수 없다.

## String 클래스 ##
- String(java.lang.String) 클래스는 문자열과 관련된 기능을 제공한다.

[ 정적 메서드 ]
- copyValueOf(char[] cs) : 문자배열 cs 가 가진 문자(char)들을 이어 붙인 문자열을 반환한다.
- format(String s, Object... os) : 주어진 형식 s 에 맞도록 하나 이상의 값 os를 순차적으로 대입한 문자열을 반환한다. 형식 s에는 아래와 같은 표현식을 사용할 수 있다.
  + %d: 정수형(byte, short, int, long) 대입
    # %,d: 천 자리 단위를 쉼표로 구분하여 대입
    # %xd: 자리수 x 자로 맞추어, 부족한 자리수 만큼 선행 공백을 추가하여 대입
    # %0xd: 자리수 x 자로 맞추어, 부족한 자리수 만큼 선행 0 을 추가하여 대입
    # %-xd: 자리수 x 자로 맞추어, 부족한 자리수 만큼 후행 공백을 추가하여 대입
    # %,xd, %0,xd, %,-xd 등의 형태로 조합하여 사용할 수 있다. 단, 천 자리 단위를 구분하기 위한 쉼표 또한 자리수(x)에 포함된다.

  + %f: 실수형(float, double) 대입
    # %,f: 천 자리 단위를 쉼표로 구분하여 대입
    # %xf: 자리수 x 자로 맞추어, 부족한 자리수 만큼 선행 공백을 추가하여 대입
    # %0xf: 자리수 x 자로 맞추어, 부족한 자리수 만큼 선행 0 을 추가하여 대입
    # %-xf: 자리수 x 자로 맞추어, 부족한 자리수 만큼 후행 공백을 추가하여 대입
    # %.nf: 소수점은 n자 까지만 표시하고, 나머지는 반올림하여 대입.
    # %x.nf, %-x.nf, %.xf, %,x.nf, %,-x.nf 등의 형태로 조합하여 사용할 수 있다.
      단, 천 자리 단위를 구분하기 위한 쉼표와 소수점을 위한 마침표 또한 자리수에 포함된다.

  + %n: 개행자 대입(경우에 따라 \n 혹은 \r\n )
  + %s: 문자열(String)대입.
    #%xs: 자리수를 x자로 맞추어, 부족한 자리수 만큼 선행하는 공백을 추가하여 대입
    #%-xs: 자리수를 x자로 맞추어, 부족한 자리수 만큼 후행하는 공백을 추가하여 대입
    #%.ns: 최대로 출력될 수 있는 문자열의 길이를 n으로 제한하여 대입.
    #%x.ns 및 %-x.ns 등의 형태로 조합하여 사용할 수 있다.

  + join(CharSequence d, CharSequence... cs): 가변인자 cs의 인자를 d 로 이어붙인 문자열을 반환한다.
  + valueOf(x): x를 문자열로 변환하여 반환한다.

[ 객체 메서드 ]
- charAt(int i) : 호출 대상인 문자열이 가지는 문자중 i 번째 문자를 반환한다. 인덱스는 0 번 부터 시작함에 유의.
- concat(String s): 호출 대상인 문자열의 내용 끝에 s 를 이어 붙인 새로운 문자열을 반환한다.
- contains(CharSequence s): 호출 대상인 문자열의 내용에 인자 s가 포함되어 있는가의 여부를 반환한다.
- endsWith(String s): 호출 대상인 문자열의 내용이 s로 끝나는가의 여부를 반환한다.
- startsWith(String s): 호출 대상인 문자열의 내용이 s로 시작하는가의 여부를 반환한다.
- equals(Object o): 전달 받은 인자 o가 문자열이라면 호출 대상인 문자열이 가지는 내용과 o가 가지는 내용이 같은가의 여부를 반환한다.
- equalsIgnoreCase(String s): equals 와 동일하나 대소문자를 구분하지 않는다.
- indexOf(String s): 호출 대상이 문자열이 가지는 내용 중 s 와 일치하는 첫번째 인덱스를 반환한다. 일치하는 내용이 없다면 -1을 반환한다.
- lastIndexOf(String s): 호출 대상이 문자열이 가지는 내용 중 s 와 일치하는 마지막 인덱스를 반환한다. 일치하는 내용이 없다면 -1을 반환한다.
- length(): 호출 대상인 문자열의 길이를 반환한다.
- matches(String s): 호출 대상인 문자열이 가지는 내용이 정규표현식 s 를 만족하는가의 여부를 반환한다.
- repeat(int n): 호출 대상인 문자열의 내용을 n 번 반복한 새로운 문자열을 반환한다.
- replace(CharSequence f, CharSequence t): 호출 대상인 문자열이 가지고있는 내용중 f 를 찾아 t 로 치환한 새로운 문자열을 반환한다.
- replaceAll(String r, String t): 호출 대상인 문자열이 가지고있는 내용중 정규 표현식 r을 만족하는 내용을 모두 t 로 치환하여 새로운 문자열을 반환한다.
- split(String r): 호출대상인 문자열이 가지는 내용에서 정규표현식 r 을 기준으로 나눈 문자열 배열을 반환한다.
- strip(): 호출 대상인 문자열의 내용에서 선후행 연속 공백을 모두 제거한 새로운 문자열을 반환한다.
- stripLeading(): 호출 대상인 문자열의 내용에서 선행 연속 공백을 모두 제거한 새로운 문자열을 반환한다.
- stripTrailing(): 호출 대상인 문자열의 내용에서 후행 연속 공백을 모두 제거한 새로운 문자열을 반환한다.
- substring(int f, int y): 호출 대상인 문자열이 가지는 내용에서 인덱스가 f 이상, t 미만인 문자열을 반환한다. 인덱스는 0 번 부터 시작한다.
- toCharArray(): 호출 대상인 문자열이 가지는 내용을 문자 배열(char[])로 반환한다.
- toLowerCase(): 호출 대상인 문자열이 가지는 내용 중 모든 라틴 문자를 소문자화하여 반환한다.
- toUpperCase(): 호출 대상인 문자열이 가지는 내용 중 모든 라틴 문자를 대문자화하여 반환한다.

## Integer 클래스 ##
- Integer (java.lang.Integer) 클래스는 일반 정수(int)와 관련된 편의 기능을 제공하고, 해당 타입 자체가 int 타입의 리터럴로 작동할 수 있는 이반 정수(int)의 래퍼(Wrapper)클래스 이다.
- Integer 클래스가 가지는 실질적인 값은 int 와 동일하나, 이는 참조 타입임으로 null 을 할당할 수 있다.

[ 정적 멤버 변수 ]
- MAX_VALUE: int 타입이 가질 수 있는 가장 큰 값.
- MIN_VALUE: int 타입이 가질 수 있는 가장 작은 값.

[ 정적 매서드 ]
- parseInt(String s): 전달된 문자열 s를 일반 정수(int)로 변환하여 반환한다. 변환할 수 없는 문자열일 경우 NumberFormatException 예외가 발생한다.
- parseInt(String s, int radix): radix 진법의 문자열 s를 10진법으로 변환한 int 를 반환한다.
- toBinaryString(int i): 정수 i를 2진법으로 변환한 문자열을 반환한다.
- toHexString(int i): 정수 i를 16진법으로 변환한 문자열을 반환한다.
- toOctalString(int i): 정수 i를 8진법으로 변환한 문자열을 반환한다.
- toString(int i): 정수 i를 문자열로 변환하여 반환한다.

[ 객체 메서드 ]
- byteValue(): 호출 대상이 가진 일반 int 값을 byte 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- shortValue(): 호출 대상이 가진 일반 int 값을 short 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- intValue(): 호출 대상이 가진 일반 int 값을 반환한다. 자동 언박싱(Auto Unboxing)을 지원함으로 int 타입의 변수에 해당 객체를 할당하여도 해당 메서드가 실행된다. 해당 객체가 null 이라면 NullPointerException 이 발생한다.
- longValue(): 호출 대상이 가진 일반 int 값을 long 타입으로 변환하여 반환한다.
- floatValue(): 호출 대상이 가진 일반 int 값을 float 타입으로 변환하여 반환한다.
- doubleValue(): 호출 대상이 가진 일반 int 값을 double 타입으로 변환하여 반환한다.
- toString(): 호출 대상이 가진 int 값을 문자열로 변환하여 반환한다.

## Long 클래스 ##
- Long (java.lang.Long) 클래스는 큰 정수(long)와 관련된 편의 기능을 제공하고, 해당 타입 자체가 long 타입의 리터럴로 작동할 수 있는 큰 정수 (long)의 래퍼(Wrapper)클래스이다.
- Long 클래스가 가지는 실질적인 값은 long 이나, 참조 타입임으로 null 을 할당 받을 수 있다.

[ 정적 멤버 변수 ]
- MAX_VALUE: long 타입이 가질 수 있는 가장 큰 값.
- MIN_VALUE: long 타입이 가질 수 있는 가장 작은 값.

[ 정적 메서드 ]
- parseLong(String s): 문자열 s를 long 타입으로 변환하여 반환한다. 변환할 수 없는 문자열일 경우 NumberFormatException 예외가 발생한다.
- parseLong(String s, int radix): radix 진법의 문자열 s 를 long 타입으로 변환하여 반환한다.
- toBinaryString(long n): long 타입인 n 을 2진수 문자열로 변환하여 반환한다.
- toOctalString(long n): long 타입인 n 을 8진수 문자열로 변환하여 반환한다.
- toHexString(long n): long 타입인 n 을 16진수 문자열로 변환하여 반환한다.
- toString(long n): long 타입인 n 을 문자열로 변환하여 반환한다.

[ 객체 메서드 ]
- byteValue(): 호출 대상이 가진 일반 long 값을 byte 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- shortValue(): 호출 대상이 가진 일반 long 값을 short 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- intValue(): 호출 대상이 가진 일반 long 값을 int 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- longValue(): 호출 대상이 가진 일반 long 값을 반환한다. 자동 언박싱(Auto Unboxing)을 지원함으로 long 타입의 변수에 해당 객체를 할당하여도 해당 메서드가 실행된다. 해당 객체가 null 이라면 NullPointerException 이 발생한다.
- floatValue(): 호출 대상이 가진 일반 long 값을 float 타입으로 변환하여 반환한다.
- doubleValue(): 호출 대상이 가진 일반 long 값을 double 타입으로 변환하여 반환한다.
- toString(): 호출 대상이 가진 long 값을 문자열로 변환하여 반환한다.

## Double 클래스 ##
- Double (java.lang.Double) 클래스는 double 타입과 관련된 편의 기능을 제공하고, 해당 타입 자체가 double 타입의 리터럴로 자동할 수 있는 double 의 래퍼(Wrapper) 클래스이다.
- Double 클래스가 가지는 실질적인 값은 double 이나, 이는 참조 타입임으로 null을 할당 받을 수 있다.

[ 정적 멤버 변수 ]
- MAX_VALUE: double 타입이 가질 수 있는 가장 큰 값.
- MIN_VALUE: double 타입이 가질 수 있는 가장 작은 값.
- NaN: 숫자가 아닌 값(Not a Number), 내부적으로 0.0 / 0 연산으로 구현되어 있다.
- NEGATIVE_INFINITY: 음의 무한대. 내부적으로 -1.0 / 0 연산으로 구현되어 있다.
- POSITIVE_INFINITY: 양의 무한대. 내부적으로 1.0 / 0 연산으로 구현되어 있다.

[ 정적 메서드 ]
- isFinite(double d): d 가 유한한가의 여부를 반환한다. 양/음수를 구분하지 않는다.
- isInfinite(double d): d 가 무한한가의 여부를 반환한다. 양/음수를 구분하지 않는다.
- isNaN(double d): d가 Double.NaN 인가의 여부를 반환한다. 어떠한 값이 NaN 인가를 검사할 때에는 절대로 동/부등(==, !=) 연산을 하지 않도록 한다.
- parseDouble(String s): 문자열 s 를 double 로 변환하여 반환한다. 변환할 수 없는 문자열일 경우 NumberFormatException 예외가 발생한다.
- toString(double d): d 를 문자열로 변환하여 반환한다.

[ 객체 메서드 ]
- byteValue(): 호출 대상이 가진 일반 double 값을 byte 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- shortValue(): 호출 대상이 가진 일반 double 값을 short 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- intValue(): 호출 대상이 가진 일반 double 값을 int 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- longValue(): 호출 대상이 가진 일반 double 값을 long 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- floatValue(): 호출 대상이 가진 일반 double 값을 float 타입으로 변환하여 반환한다. 오버/언더플로우가 발생할 수 있음.
- doubleValue(): 호출 대상이 가진 일반 double 값을 반환한다. 자동 언박싱(Auto Unboxing)을 지원함으로 double 타입의 변수에 해당 객체를 할당하여도 해당 메서드가 실행된다. 해당 객체가 null 이라면 NullPointerException 이 발생한다.
- isInfinite(): 호출 대상이 가지고 있는 double 값이 무한한가의 여부를 반환한다.
- isNan(): 호출 대상이 가지고 있는 double 값이 NaN 인가의 여부를 반환한다.
- toString(): 호출 대상이 가진 double 값을 문자열로 변환하여 반환한다.

## Math 클래스 ##
- Math (java.lang.Math) 클래스는 수학과 관련된 편의 기능을 제공하는 유틸리티 클래스이다.

[ 정적 멤버 변수 ]
- E: 자연 상수(e)
- PI: 원주율(rr)

[ 정적 메서드 ]
- abs(x): 숫자 x의 절대값을 반환한다.
- absExact(x): 정수 x 의 절대값을 반환한다. 단, 오버플로우가 발생할 경우 ArithmeticException 예외가 발생한다.
- pow(a, b): 숫자 a의 b 제곱(a의 b승)을 반환한다.
- ceil(x): double 인 x 의 소수부를 올림하여 반환한다.
- floor(x): double 인 x 의 소수부를 내림하여 반환한다.
- round(x): double 인 x 의 소수부를 반올림하여 반환한다.
- max(a, b): 숫자 a 와 b 중 큰 값을 반환한다.
- min(a, b): 숫자 a 와 b 중 작은 값을 반환한다.
- sqrt(x): 숫자 x 의 제곱근을 반환한다.
- cbrt(x): 숫자 x의 세제곱근을 반환한다.
- log(x): 숫자 x 의 자연로그를 반환한다.
- log10(x): 숫자 x의 상용로그르 반환한다.
- random(): 0 이상 1 미만의 무작위 실수를 반환한다.
- addExact(a, b): 정수 a 와 b 의 합을 반환한다. 단, 오버/언더플로우가 발생할 경우 ArithmeticException 예외가 발생한다.
- subtractExact(a, b): 정수 a 와 b 의 차을 반환한다. 단, 오버/언더플로우가 발생할 경우 ArithmeticException 예외가 발생한다.
- multiplyExact(a, b): 정수 a 와 b 의 곱을 반환한다. 단, 오버/언더플로우가 발생할 경우 ArithmeticException 예외가 발생한다.
- multiplyFull(a, b): 일반 정수(int) a 와 b 의 곱을 큰 정수(long)로 반환한다.
- negateExact(x): 정수 x 의 부호를 반전하여 반환한다. 단, 오버/언더플로우가 발생할 경우 ArithmeticException 예외가 발생한다.
- decrementExact(x): 정수 x 에서 1을 뺀 값을 반환한다. 단, 언더플로우가 발생할 경우 ArithmeticException 예외가 발생한다.
- incrementExact(x): 정수 x 에서 1을 더한 값을 반환한다. 단, 오버플로우가 발생할 경우 ArithmeticException 예외가 발생한다.
- toIntExact(long x): 큰 정수(long)인 x를 정수(int)로 변환하여 반환한다. 단, 오버/언더 플로우가 발생할 경우 ArithmeticException 예외가 발생한다.

## 정적 ##
- 자바에서 정적(static)인 리소스는 프로그램이 실행되는 순간 main 메서드가 실행되기 전 모두 선언된다.
- 반대로 비정적(Non-static)인 리소스는 해당 리소스를 포함하는 구성요소가 객체화될 때 혹은 메서드가 실행될 때 선언된다.
- 따라서, 비정적인 대상이 정적인 대상에 접근하는 것은 항상 허용되지만, 정적인 대상이 비정적인 대상에 접근하는 것은 경우에 따라 허용되지 않을 수 있다.(객체화의 순서에 의거)

## 패키지 ##
- 패키지(Package)는 동일한 이름을 가지는 클래스(등의 구성요소)가 동일한 경로에 존재할 수 없는 문제를 해결하기 위해 존재하는 디렉토리이다.
- 주로 구성요소를 종류별, 목적별로 구분하여 위치시키기 위해 사용한다.
- 루트 패키지(Root Package)이ㅡ 경로는 [소유하고 있는 도메인의 역순].[아티팩트 ID] 형식으로 구성한다.(가령, com.naver + cafe)

## 캡슐화 ##
- 캡슐화(Encapsulation)은 주로 엔티티(Entity) 클래스, 값 객체(VO, Value Object), 데이타 전달 객체(Data Transfer Object) 등이 가지는 멤버 변수와 외부 접근을 차단하고, 필요에 따라 해당 멤버 변수를 반환해 주기 위한 게터(Getter) 및 새로운 값을 할당하고 해당 값에 대한 논리를 작성하기 위한 세터(Setter) 메서드를 별도로 구현하는 방법을 의미한다.

## 접근 제한자 ##
- 접근 제한자는 특정 멤버에 접근할 수 있는 대상을 제한하기 위해 사용한다.
- public: 제한 없음.
- protected: 동일한 패키지 경로에 있거나 상속 관계에 있는 대상만 접근가능.
- (default): 동일한 패키지 경로에 있는 대상만 접근 가능.
- private: 동일한 클래스 내에서만 접근가능.

## 다형성 ##
- 다형성(Polymorphism)은 어떠한 타입을 가지는 객체가 다른 타입으로 변할 수 있는 성질을 의미한다.
- 클래스 간의 상속 관계
  + 자식 객체는 부모 타입에 묵시적 형변환을 통해 할당될 수 있다.
  + 부모 객체는 자식 타입에 묵시적 형변환을 통해 할당될 수 없다.
- 클래스와 인터페이스의 구현 관계
  + 특정 인터페이스를 구현하는 클래스 객체는 인터페이스 타입에 할당될 수 있다.

## 열거형 ##
- 열거형(Enumeration)은 어떠한 타입이 가질 수 있는 값의 개수나 종류가 능동적으로 늘거나 줄지 않고 고정적일 것으로 판단될 때 분류의 목적으로 사용한다.
- 열거형의 명명법: 파스칼 케이스
- 열거형이 가지는 인자의 명ㅁ여법: 대문자 스네이크 케이스
- 모든 열거형 T 는 Enum<T> 타입을 상속받는다. 고로 열거형으로 하여금 별도의 클래스를 상속받도록(extends) 할 수 없다.
- 열거형의 구조는 아래와 같다.
  [접근 제한자] enum [열거형 이름] [implements [구현할 인터페이스,...]]? {
    [인자, ...]
    [; 열거형 인자 멤버]?
  }
  #개발자간에 소통이나 문제나, 오탈자 등의 의한 인적 오류를 철저하게 예방할 수 있다. (틀리면 컴파일 자체가 안됨으로)
  #열거형이 가지는 인자는 모두 정적인 읽기 전용(static final)이기 때문에 동등(==) 및 부등(!=) 연산을 사용하여도 된다.

## 인터페이스 ##
- 인터페이스(Interface)는 특정(직렬)계열에 공통적을 적용되는 사항이 아닌, 특정 클래스에 대한 속성이나 부분적으로 특화되어 있는 기낭의 집합에 대한 틀을 제공하기 위해 사용한다.
- 명명법: 파스칼 케이스, 대문자 I로 시작하는 파스칼 케이스(IFlyable)
- 인터페이스의 구조는 아래와 같다.
  [접근 제한자] interface [인터페이스 이름] [extends 상속 인터페이스]? {
    [멤버]
  }
  #인터페이스는 여러개의 인터페이스를 상속 받을 수 있지만, 클래스를 상속 받을 수는 없다.
  #인터페이스가 가지는 모든 멤버의 접근 제한자는 기본적으로 public 이다.
  #단, 메서드의 접근 제한자가 private 일 수 있는데, 이 경우 해당 메서드는 구현부를 가져야 한다(추상적이지 않아야한다).
  #인터페이스가 가지는 모든 멤버 변수는 정적이고 읽기 전용(static final)이다.
  #인터페이스가 가지는 모든 메서드는 기본적으로 추상적(abstract)이다.
  #단, 메서드의 반환 타입 앞에 default 라는 키워드를 추가하여 해당 메서드가 기본 동작 방식을 가진다고 정의하고, 구현부를 정의할 수 있다. 이때 default 키워드는 접근제한자와는 관계가 없음에 유의.

## 예외 ##
[ Throwable ]
- Throwable (java.lang.Throwable) 클래스는 '던질수 있는' 이라는 의미로 자바 내에서 발생시킬 수 있는 일반적인 의미의 오류의 최상위 타입이다.
- try - catch 및 메서드의 throws 시그니처 대상이 되기 위해서는 직/간접적으로 Throwable 타입을 상속 받아야 한다.

[ Error ]
- Error (java.lang.Error) 클래스는 Throwable 을 상속받아 자바 실행 중 발생할 수 있는 환경 요인에 의한 오류를 구현한다.
- 일반적으로 개발자의 개발 실수로 인해 발생하는 문제를 구현하지 않는다. 주로 하드웨어의 메모리 부족이나 가상환경(JVM)에 치명적인 오류가 있을때 발생한다.
- 개발자가 직접 Error 클래스를 상속 받아 사용자의 정의의 Error 를 만들거나, 고의로 발생시키는 것은 권장되지 않는다.
- Unchecked Throwable 로, 별도의 명시나 처리 없이 발생시킬 수 있다.
- Error 를 상속받는 대표적인 예
  + OutOfMemoryError: 가상 머신에 할당된 메모리가 부족하여 발생.
  + StackOverFlowError: 스택 오버플로우로 인해 발생.
  + VirtualMachineError: 가상 환경(JVM)과 관련된 문제로 발생.

[ Exception ]
- Exception (java.lang.Exception) 클래스는 Throwable 을 상속 받아 자바 실행 중 발생할 수 있는 일반적인 오류를 구현한다.
- 예외는 크게 RuntimeException 클래스를 직/간접적으로 상속 받는 것과, 그렇지 않은 것으로 나누어진다.
- 사용자 정의의 오류가 필요하다면, Exception 혹은 RuntimeException 을 상속 받아 사용하는 것이 좋다.
- Exception 자체는 Checked Throwable 이다.
# RuntimeException 을 상속받는 것
  - Unchecked Throwable 로, 별도의 명시나 처리 없이 발생시킬 수 있다.
  - 대표적인 예
    + NullPointerException: 참조 타입의 변수가(스택 값) 가리키고 있는 힙의 주소가 없는 경우에서 이의 멤버에 접근하려 했을 때 발생한다.
    + ArrayIndexOutOfBoundsException: 배열 등에서 그 범위를 벗어난 인덱스에 접근하려 하였을 때 발생한다.
    + ArithmeticException: 수학 및 사칙연산과 관련하여 문제가 있을때 발생한다.
    + NumberFormatException: 문자열을 숫자로 변환하려 하였을 때 숫자로 변환할 수 없는 문자열을 인자로 전달한 경우 등에 발생한다.
# RuntimeException 을 상속받지 않는 것
  - Checked Throwable 로, 별도의 명시나 처리 없이 발생시킬 수 없다.
  - 대표적인 예
    + IOException: 파일 입출력 및 네트워크 통신 등 관련하여 오류가 있을 때 발생한다.
    + InterruptedException: 외부 요인으로 스레드가 비정상 종료되었을 때 발생한다.
    + TimeOutException: 어떠한 작업에 대한 제한된 시간이 초과되었을 때 발생한다.

[ Throwable 던지기 ]
- 고의로 Throwable 을 던지기 위해 Throw 키워드를 활용한다.
  throw [Throwable 을 상속 받는 객체];
  #가령, NullPointerException 을 고의로 발생시키기 위해 아래와 같이 작성할 수 있다.
  (1) 대부분 사용하는 방식
  throw new NullPointerException();
  (2) 거의사용하지 않는 방식
  NullPointerException e = new NullPointerException();
  throw e;
  #단, 변수를 throw 하는 경우 객체화된 타입이 아닌 최종적으로 throw 하는 타입을 참고함으로 다형성에 의거, Checked 및 Unchecked 여부를 잘 확인하여야 한다.
- 발생시키고자 하는 Throwable 이 Checked Throwable 이라면, 던지는 구문이 try - catch 의 try 구현부 내에 있거나, 메서드의 throws 시그니처가 존재하여야 한다.

[ try-catch ]
- try-catch 문의 try 가 가지는 구현부 안에서 발생하는 오류에 대해 오류를 발생시키지 않고(JVM 에 넘기지 않고) catch 에서 원하는 로직을 실행하기 위해 사용한다.
- try-catch 문의 구조는 아래와 같다.
  try {
    [구현부]
  } catch ([처리할 예외 선언 1]) {
    [예외 1 발생시 실행할 구현부]
  } catch ([처리할 예외 선언 2]) {
    [예외 2 발생시 실행할 구현부]
  } catch ([처리할 예외 선언 3]) {
    [예외 3 발생시 실행할 구현부]
  } finally {
    [최종 구현부]
  }
  #하나의 try 는 여러개의 catch 를 가질 수 있다.
  #단, 반드시 하나 이상의 catch 를 포함하여야 한다.
  #여러개의 catch 를 사용할 때 각 catch 는 동일한 타입의 예외를 가져서는 안되며, 선행하는 예외가 후행하는 예외보다 부모여서는 안 된다.
  #catch 하는 예외가 checked Throwable 일 경우 해당 예외를 던질 수 있는 가능성이 있는 로직이 try 내부에 구현되어 있어야 한다.(Exception 은 예외)
  #finally 문은 선택 사항이며, 이가 가지는 구현부는 try 문을 정상 실행하였든, 오류가 발생하여 catch 문으로 빠졌든 반드시 실행됨을 보장받는다. 모든 catch 보다 아래에 있어야하고, 없거나, 한개만 사용할 수 있다.
  #catch 나 finally 문에서 실행되는 구현부는 예외처리가 되지 않음에 유의한다.

## 메서드 시그니처 ##
- 예외를 처리하기 위해 try-catch 를 사용하지 않고 메서드의 throws 시그니처를 사용할 경우 발생하는 예외를 메서드 내부의 로직에서 처리하는 것이 아니라, 해당 메서드의 호출자에게 전가하여 예외에 대한 로직을 호출자가 처리하게끔 한다.
- 예외 시그니처가 명시되어있는 메서드를 호출하는 호출자는 명시된 예외에 대한 적절한 처리 없이 해당 메서드를 호출할 수 없다.(Unchecked Throwable 제외)
  [메서드 구조] throws [예외,...] {
    [구현부]
  }
  #가령, HTTP 요청을 전송하고 응답을 받아오는 메서드를 작성하기 위한 예시는 다음과 같다.
  public static String sendGetRequest(String url) throws IOException, InterruptedException {
    HttpClient client = httpClient.newHttpClient();
    httpRequest request = HttpRequest.newBuilder()
            .url(URI.create(url))
            .GET()
            .build();
    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
    return response.body();
  }




@@ 단축키 메모 @@
getter & setter 만들기 = Alt + Insert